# What happened??
The timings may be too tight with the original design, being forced to act in under 20ns. The fix is that instead of using each VGA pixel cycle to write data and preload, use four cycles to write and four to preload. This is good because it has MUCH longer to act, and I can therefore use a more covnentional 128k x 8 SRAM. It can easily act within 55ns, unlike the 12ns one.

## Advancements?
The first half of the 8-cycle period is for writing data. The multiplexers are set to the addresses in the registers, and a writing state is initialized. This will take upwards of 40 x 4ns, or 160ns. This is well within the allowed time. When powering up the card, the preload register is initialized to 0x00. The preload phase is on the other half, directly controlled by X2. WHen in the preload phase, it is set to read mode, and the address is switched to the counters. At the same time, the latch is enabled, allowing the data to be laoded. Since this is technically happening half way through the byte, everything will be shifted over some. To prevent the slow access time from bugging out some pixels, the data is only committed at the last cycle. Software should be able to counteract this.

## What works?
The signal generation works well, as it is within the allowable timeframe. I suspect that the main cause was the slowness of the 74LS20 chip, though I can't know for sure. The only way to test it for certain is to buy a 74HC/AC20 and plug it in. Overall the timing may be too restrictive for these chips, and in that case it may be worth it to simply convert over to the less harsh design. It may use more board space however, specifically around the control section. If the user decides to change the X/Y coordinate immediatly before the writing of the data, and a timing contention happens, nothing bad happens. If the address is late, it will simply write the old data into the new location. It will almost instantly be overwritten next phase.

## Extra parts
The previous design used a NAND and a 4-input NAND to control the operation. Instead, Alternate read/write cycles by using X2, which should be fast enough. A 3-input AND gate can be used to time the latching circuit, taking in X0, X1, X2. it would it irrespective of the clock phase.

## Conclusion
The write phase will not collide with the read phase at all, and this allows for better timings. Since each stage has 160ns to act, that is WAY more than enough time to work. The main focus is the preload time, which is arguably the most vital step. It allows three cycles, or 120ns, to read. This can then be latched, and since it is mostly irrespective of clock, takes 40ns. This is good enough. Things will be shifted over by one, since it will technically be loading the previous set of pixels and then displaying them later. Either software can shift, or nothing happens at all. Everything is shifted over by 7-8 pixels, and it should be basically invisible to the user.

# Oscilloscope

The oscilloscope likes to smooth off bad edges, and timing issues are a major cocern. It may not be rated for these sorts of speeds, though should do fine for now. The circuit works in theory, but in practice the timings are impossible.

## Practical circuit application
The signal generator will be exactly the same as before. Six comparators get the start and end of each sync pulse, as well as the time tk reset to the Y counter. These go into a flip-flop, to maintain the state of each sync pulse. They also go into inverters for the counter control logic. The counters are updated on the falling edge of the vga clock. The registers are also the same, as timing is not an issue. A 74HC238 decoder is updated for each one, and is managed by the device select, PHI2, and the RWB signal. The multiplxers for the address are tied between the pixel counters and the user-defined locations. These are always outputting and are controlled by the X2 bit. If X2 is low, enable the user-defined registers. Otherwise, define the pixel counters during preload. These technically change every 160ns, giving the SRAM plenty of time. The SRAM is an HM628128 with a 55ns access time. Both chip selects are ON, and it is toggled between OEB and WEB. OEB/WEB signals are defined by the X2 bit again, so it is always complimentary and very stable. A three-input AND gate is used to control the latching of the preload register, and that register feeds in to an 8-1 multiplexer. That is controlled by X0, X1, and X2. The frame select is not time-dependant that much, and the architecture can be carried over. The only difference is the added latch enable controller, which uses a 3-input AND. When the clock goes over into the next byte, latching is disabled and the addresses are switched. Since it is controlled directly by fast counters, the latch should disable itself faster than the addresses are able to switch over.
